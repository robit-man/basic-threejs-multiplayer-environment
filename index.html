<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Threejs Multiplayer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #modal.show {
            display: flex;
        }

        #modal-content {
            background: #fff;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            font-family: sans-serif;
            text-align: center;
        }

        #modal-content input {
            width: 300px;
            padding: 0.5rem;
            margin-top: 1rem;
            font-size: 1rem;
        }

        #modal-content button {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            font-size: 1rem;
        }
    </style>
</head>

<body>
    <div id="modal">
        <div id="modal-content">
            <h2>Enter signaling server URL</h2>
            <input id="serverUrl" type="text" placeholder="https://example.com" />
            <br>
            <button id="connectBtn">Connect</button>
        </div>
    </div>

    <!-- Dependencies -->
    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>
    <script type="importmap">
  {
    "imports": {
      "three":               "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.min.js",
      "Sky":                 "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/objects/Sky.min.js",
      "PointerLockControls": "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/controls/PointerLockControls.min.js",
      "socket.io":           "https://cdn.jsdelivr.net/npm/socket.io-client@4.5.4/dist/socket.io.esm.min.js"
    }
  }
  </script>

    <script type="module">
        import * as THREE from 'three';
        import { Sky } from 'Sky';
        import { PointerLockControls } from 'PointerLockControls';
        import { io } from 'socket.io';

        // ── Mobile Device Orientation Helpers ───────────────────────────────────
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        let orientationPermissionAsked = false;
        let orientationOk = false;
        let orientation = { alpha: 0, beta: 0, gamma: 0 };
        let accel = { x: 0, y: 0, z: 0 };
        let compassVal = 0;
        // ——— slide–vector & touch handler with variable speed ———
        let touchStart = null;
        const touchThreshold = 10;   // px before activation
        const maxSlideDist = 200;  // px mapped to full speed
        let slideVector = { x: 0, y: 0 }; // x=right+, y=down+
        let slideMagnitude = 0;    // 0–1
        let pendingTileSpawn = false;

        function showMotionPrompt() {
            return new Promise(res => {
                const wrap = document.createElement("div");
                wrap.style.cssText = `
        position:fixed;inset:0;display:flex;
        align-items:center;justify-content:center;
        background:rgba(0,0,0,.65);z-index:9999`;
                wrap.innerHTML = `
        <div style="background:#222;color:#fff;
                    padding:1rem 1.5rem;border-radius:8px;
                    max-width:260px;text-align:center;">
            <p><strong>Enable motion/orientation?</strong></p>
            <p>This lets your peer see how you tilt and move the phone.</p>
            <button id="perm-ok"   style="margin-right:.5rem;">Allow</button>
            <button id="perm-cancel">Deny</button>
        </div>`;
                document.body.appendChild(wrap);

                wrap.querySelector("#perm-ok").onclick = () => { wrap.remove(); res(true); };
                wrap.querySelector("#perm-cancel").onclick = () => { wrap.remove(); res(false); };
            });
        }

        async function ensureOrientationPermission() {
            if (!isMobile || orientationPermissionAsked) return;
            orientationPermissionAsked = true;

            const needIOSPrompt =
                typeof DeviceOrientationEvent === "function" &&
                typeof DeviceOrientationEvent.requestPermission === "function";

            const ok = await showMotionPrompt();
            if (!ok) return;

            if (needIOSPrompt) {
                try {
                    const status = await DeviceOrientationEvent.requestPermission();
                    if (status !== "granted") return;
                } catch { return; }
            }
            registerMotionListeners(true);
        }

        function registerMotionListeners(replace = false) {
            if (replace) {
                window.removeEventListener("deviceorientation", handleOrientation, true);
                window.removeEventListener("devicemotion", handleMotion, true);
            }
            window.addEventListener("deviceorientation", handleOrientation, true);
            window.addEventListener("devicemotion", handleMotion, true);
        }

        function handleOrientation(ev) {
            if (!orientationOk &&
                ev.alpha === null && ev.beta === null && ev.gamma === null) {
                ensureOrientationPermission();
                return;
            }
            orientationOk = true;
            orientation.alpha = ev.alpha ?? 0;
            orientation.beta = ev.beta ?? 0;
            orientation.gamma = ev.gamma ?? 0;
        }

        function handleMotion(ev) {
            accel.x = ev.accelerationIncludingGravity?.x ?? 0;
            accel.y = ev.accelerationIncludingGravity?.y ?? 0;
            accel.z = ev.accelerationIncludingGravity?.z ?? 0;
            compassVal = ev.rotationRate?.alpha ?? compassVal;
        }

        // start listening now (will no-op on desktop)
        registerMotionListeners();

        // ── Utilities ───────────────────────────────────────────────────────────
        class Utils {
            static smoothstep(t) { return t * t * (3 - 2 * t); }
        }

        class UniformHexGrid100 {
            constructor(spacing = 1, size = 100, amplitude = 5) {
                this.amplitude = amplitude;
                this.spacing = spacing;        // ← make spacing available below
                this.gridRadius = size / 2;       // hex “radius” in metres
                this._generateAllRings();
                this._buildGeometry();
                this._initUserData();
            }

            _generateAllRings() {
                const s = this.spacing;
                const h = Math.sqrt(3) / 2 * s;
                const N = Math.floor(this.gridRadius / s);

                this.targetPositions = [];
                this.triangles = [];
                const idxMap = {};
                let idx = 0;

                // 1) place every triangular‐lattice point whose (i,j,i+j) coords lie within a cube‐radius N
                for (let j = -N; j <= N; j++) {
                    for (let i = -N; i <= N; i++) {
                        if (Math.max(Math.abs(i), Math.abs(j), Math.abs(i + j)) > N) continue;
                        // map (i,j) → Cartesian on a triangular grid
                        const x = (i + j / 2) * s;
                        const z = j * h;

                        idxMap[`${i},${j}`] = idx;
                        this.targetPositions.push(x, 0, z);
                        idx++;
                    }
                }

                // 2) stitch each little quad into two triangles
                for (let j = -N; j < N; j++) {
                    for (let i = -N; i < N; i++) {
                        const a = idxMap[`${i},${j}`],
                            b = idxMap[`${i + 1},${j}`],
                            c = idxMap[`${i},${j + 1}`],
                            d = idxMap[`${i + 1},${j + 1}`];
                        if (a != null && b != null && c != null) this.triangles.push(a, b, c);
                        if (b != null && d != null && c != null) this.triangles.push(b, d, c);
                    }
                }
            }

            _buildGeometry() {
                this.geometry = new THREE.BufferGeometry();
                this.geometry.setAttribute(
                    'position',
                    new THREE.Float32BufferAttribute(new Float32Array(this.targetPositions), 3)
                        .setUsage(THREE.DynamicDrawUsage)
                );
                this.geometry.setIndex(this.triangles);
                this.geometry.computeVertexNormals();
            }

            _initUserData() {
                const mat = new THREE.MeshLambertMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                this.mesh = new THREE.Mesh(this.geometry, mat);
                this.mesh.castShadow = this.mesh.receiveShadow = true;
                this.group = new THREE.Group();
                this.group.add(this.mesh);
            }

            get object() { return this.group; }
        }
        // ── TileManager (flat‐topped axial layout + on‐demand expansion) ──────────
        class TileManager {
            constructor(spacing, tileRadius, amplitude) {
                this.spacing = spacing;
                this.tileRadius = tileRadius;  // hex “radius” in meters
                this.amplitude = amplitude;
                this.tiles = new Map();
                this.addTile(0, 0);
            }

            addTile(q, r) {
                const diameter = this.tileRadius * 2;
                const grid = new UniformHexGrid100(this.spacing, diameter, this.amplitude);
                // flat‐topped layout:
                const a = this.tileRadius,
                    x = a * (3 / 2 * q),
                    z = a * (Math.sqrt(3) / 2 * q + Math.sqrt(3) * r);
                grid.group.position.set(x, 0, z);
                scene.add(grid.group);
                this.tiles.set(`${q},${r}`, { grid, q, r });
            }

            update(position) {
                const a = this.tileRadius,
                    qf = ((Math.sqrt(3) / 3) * position.x - (1 / 3) * position.z) / a,
                    rf = ((2 / 3) * position.z) / a,
                    q0 = Math.round(qf), r0 = Math.round(rf),
                    dq = qf - q0, dr = rf - r0, ds = -dq - dr,
                    maxFrac = Math.max(Math.abs(dq), Math.abs(dr), Math.abs(ds));

                // only once you move past 90% to an edge
                if (maxFrac < 0.9) return;

                const dirs = [[1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]];
                let bestDot = 0, bestDir = null;
                for (const [dqOff, drOff] of dirs) {
                    const dot = dq * dqOff + dr * drOff;
                    if (dot > bestDot) { bestDot = dot; bestDir = [dqOff, drOff]; }
                }
                if (bestDir && bestDot > 0.7) {
                    const [dqOff, drOff] = bestDir,
                        key = `${q0 + dqOff},${r0 + drOff}`;
                    if (!this.tiles.has(key)) this.addTile(q0 + dqOff, r0 + drOff);
                }
            }
        }


        let tileManager;


        // ── GPS & Elevation Mapping ─────────────────────────────────────────────
        const EKEY = 'elevCacheV1', ERAD = 100;
        function loadCache() { try { return JSON.parse(localStorage.getItem(EKEY) || '[]'); } catch { return []; } }
        function saveCache(a) { try { localStorage.setItem(EKEY, JSON.stringify(a)); } catch { } }
        const elevCache = loadCache();

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) ** 2;
            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
        function cachedElev(lat, lon) {
            for (const r of elevCache) {
                if (haversine(lat, lon, r.lat, r.lon) <= ERAD) return r.elev;
            }
            return null;
        }
        function addCache(lat, lon, e) {
            elevCache.push({ lat, lon, e });
            saveCache(elevCache);
        }

        let origin = null;
        function activateGpsMapping(gridInstance) {
            window.addEventListener('load', () => startGps(gridInstance));
            if (/Mobi|Android/i.test(navigator.userAgent)) {
                setTimeout(() => startGps(gridInstance), 5000);
            }
        }
        function startGps(gridInstance) {
            if (!navigator.geolocation) return console.error('Geolocation unsupported');
            const handler = pos => {
                const { latitude: lat, longitude: lon } = pos.coords;
                if (!origin) {
                    const s = localStorage.getItem('userGpsOrigin');
                    if (s) origin = JSON.parse(s);
                    else {
                        origin = { lat, lon };
                        localStorage.setItem('userGpsOrigin', JSON.stringify(origin));
                    }
                }
                document.dispatchEvent(new CustomEvent('gps-updated', { detail: { lat, lon } }));
            };
            navigator.geolocation.getCurrentPosition(handler, e => console.error(e));
            navigator.geolocation.watchPosition(handler, e => console.error(e), {
                enableHighAccuracy: true,
                maximumAge: 10000
            });
        }

        function rebuildElevations(gridInstance) {
            if (!origin) return;

            const attr = gridInstance.geometry.attributes.position;
            const tp = attr.array;
            const n = tp.length / 3;
            const mLat = 111320, mLon = 111320 * Math.cos(origin.lat * Math.PI / 180);
            let normOff = null;
            const idxs = [];
            for (let i = 0; i < n; i++) idxs.push({ i, d: Math.hypot(tp[3 * i], tp[3 * i + 2]) });
            idxs.sort((a, b) => a.d - b.d);
            idxs.forEach(({ i }, order) => {
                const ix = 3 * i, x = tp[ix], z = tp[ix + 2];
                const latP = origin.lat + z / mLat;
                const lonP = origin.lon + x / mLon;
                const hit = cachedElev(latP, lonP);
                const delay = hit != null ? 0 : order * 30;
                setTimeout(() => {
                    const apply = raw => {
                        if (order === 0) normOff = raw;
                        const fe = raw - (normOff || 0);
                        tp[ix + 1] = fe;
                        attr.needsUpdate = true;
                        gridInstance.geometry.computeVertexNormals();
                    };
                    if (hit != null) apply(hit);
                    else {
                        fetch(`https://epqs.nationalmap.gov/v1/json?x=${lonP}&y=${latP}&wkid=4326&units=Meters`)
                            .then(r => r.json()).then(d => {
                                const raw = d.value != null ? d.value : tp[ix + 1];
                                addCache(latP, lonP, raw);
                                apply(raw);
                            }).catch(() => apply(tp[ix + 1]));
                    }
                }, delay);
            });
        }

        // ── Sky & Sun + Moonlight ──────────────────────────────────────────────
        let sky, sunVector, sunLight, moonLight;
        function initSky() {
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);
            sunVector = new THREE.Vector3();
            sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.castShadow = true;
            scene.add(sunLight);
            moonLight = new THREE.DirectionalLight(0x8888aa, 0.2);
            scene.add(moonLight);
        }
        function updateSun(lat, lon) {
            const now = new Date();
            const pos = SunCalc.getPosition(now, lat, lon);
            const elev = pos.altitude * 180 / Math.PI;
            const az = pos.azimuth * 180 / Math.PI;
            const phi = THREE.MathUtils.degToRad(90 - elev);
            const th = THREE.MathUtils.degToRad(az);
            sunVector.setFromSphericalCoords(1, phi, th);
            sky.material.uniforms.sunPosition.value.copy(sunVector);
            if (elev > 0) {
                sunLight.intensity = 1.5 * (elev / 90 + 0.1);
                moonLight.visible = false;
            } else {
                sunLight.intensity = 0;
                moonLight.visible = true;
                moonLight.position.copy(sunVector).multiplyScalar(-100000);
                moonLight.target.position.set(0, 0, 0);
                moonLight.target.updateMatrixWorld();
            }
        }

        // ── Scene & Signaling Setup ─────────────────────────────────────────────
        const DEFAULT_SERVER = 'https://ipfs-signaling-vr.loca.lt';
        let socket, scene, camera, renderer, controls, dolly, gridInstance, gridMesh;
        const clock = new THREE.Clock();
        const movement = { forward: false, backward: false, left: false, right: false };
        const peerBalls = {};
        const raycaster = new THREE.Raycaster();
        const DOWN = new THREE.Vector3(0, -1, 0);
        const RAY_START_H = 100, EYE_HEIGHT = 1.6;


        // Save position & look direction
        let saveTimeout;
        function scheduleSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                const p = dolly.position;
                localStorage.setItem('userPosition', JSON.stringify([p.x, p.y, p.z]));
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                localStorage.setItem('userDirection', JSON.stringify([dir.x, dir.y, dir.z]));
            }, 200);
        }

        initScene();
        attemptDefaultConnect();
        animate();

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x808080);

            camera = new THREE.PerspectiveCamera(
                50, window.innerWidth / window.innerHeight, 0.1, 2000000
            );
            controls = new PointerLockControls(camera, document.body);
            dolly = controls.getObject();

            // ——— Mobile: prompt for orientation permission ———
            if (isMobile) {
                ensureOrientationPermission();
            }

            // Restore look direction
            const dirS = localStorage.getItem('userDirection');
            if (dirS) {
                try {
                    const [dx, dy, dz] = JSON.parse(dirS);
                    const dir = new THREE.Vector3(dx, dy, dz);
                    const yaw = Math.atan2(-dir.x, -dir.z);
                    const pitch = Math.asin(THREE.MathUtils.clamp(dir.y, -1, 1));
                    dolly.rotation.y = yaw;
                    dolly.children[0].rotation.x = pitch;
                } catch { }
            }

            // Restore position – catch malformed
            const posS = localStorage.getItem('userPosition');
            if (posS) {
                try {
                    const arr = JSON.parse(posS);
                    if (Array.isArray(arr) && arr.length === 3) {
                        const [x, y, z] = arr;
                        dolly.position.set(x, y, z);
                    }
                } catch { }
            } else {
                dolly.position.set(0, EYE_HEIGHT, 0);
            }

            scene.add(dolly);
            document.body.addEventListener('click', () => controls.lock());

            // broadcast on orientation change as well as on movement
            controls.addEventListener('change', () => {
                if (socket && socket.connected) broadcastPosition();
            });


            initSky();
            // ── Initialize TileManager instead of single grid ─────────────────────
            tileManager = new TileManager(1, 50, 5);

            // pull out the actual UniformHexGrid100 instance…
            const centralEntry = tileManager.tiles.get('0,0');
            const centralGrid = centralEntry.grid;

            // now point your ray‐caster at its mesh  
            gridMesh = centralGrid.mesh;

            // and wire up GPS/elevation against the real grid instance
            activateGpsMapping(centralGrid);
            document.addEventListener('gps-updated', () => {
                tileManager.tiles.forEach(({ grid }) => rebuildElevations(grid));
            }, { once: true });


            scene.add(new THREE.HemisphereLight(0x808080, 0x606060));

            window.addEventListener('keydown', e => { setMovement(e.code, true); scheduleSave(); });
            window.addEventListener('keyup', e => { setMovement(e.code, false); scheduleSave(); });
            window.addEventListener('pointermove', () => controls.isLocked && scheduleSave());


            window.addEventListener('touchstart', e => {
                const t = e.touches[0];
                touchStart = { x: t.clientX, y: t.clientY };
            }, { passive: true });

            window.addEventListener('touchmove', e => {
                if (!touchStart) return;
                const t = e.touches[0];
                const dx = t.clientX - touchStart.x;
                const dy = t.clientY - touchStart.y;
                const dist = Math.hypot(dx, dy);

                if (dist > touchThreshold) {
                    slideVector.x = dx / dist;
                    slideVector.y = dy / dist;
                    slideMagnitude = Math.min((dist - touchThreshold) / (maxSlideDist - touchThreshold), 1);
                } else {
                    slideVector.x = 0;
                    slideVector.y = 0;
                    slideMagnitude = 0;
                }

                e.preventDefault();
            }, { passive: false });

            window.addEventListener('touchend', () => {
                slideVector.x = 0;
                slideVector.y = 0;
                slideMagnitude = 0;
                touchStart = null;
            }, { passive: true });


            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        function setMovement(code, val) {
            switch (code) {
                case 'KeyW': case 'ArrowUp': movement.forward = val; break;
                case 'KeyS': case 'ArrowDown': movement.backward = val; break;
                case 'KeyA': case 'ArrowLeft': movement.left = val; break;
                case 'KeyD': case 'ArrowRight': movement.right = val; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            updateLocalMovement(delta);
            updatePeers();
            if (origin) updateSun(origin.lat, origin.lon);

            // ——— Mobile: apply device orientation to look ———
            if (isMobile && orientationOk) {
                const { alpha, beta, gamma } = orientation;
                const a = THREE.MathUtils.degToRad(alpha);
                const b = THREE.MathUtils.degToRad(beta);
                const g = THREE.MathUtils.degToRad(gamma);

                const euler = new THREE.Euler(b, a, -g, 'YXZ');
                const quat = new THREE.Quaternion().setFromEuler(euler);
                const corr = new THREE.Quaternion().setFromAxisAngle(
                    new THREE.Vector3(1, 0, 0),
                    -Math.PI / 2
                );
                quat.multiply(corr);
                dolly.quaternion.copy(quat);

                // broadcast new look direction
                if (socket && socket.connected) {
                    broadcastPosition();
                }
            }

            renderer.render(scene, camera);

            // after rendering, spawn any needed tile without blocking motion
            if (pendingTileSpawn) {
                pendingTileSpawn = false;
                const spawn = () => tileManager.update(dolly.position);
                if ('requestIdleCallback' in window) {
                    // optional second arg must be an object, so we'll omit it
                    window.requestIdleCallback(spawn);
                } else {
                    setTimeout(spawn, 0);
                }
            }
        }


        function getHeightAt(x, z) {
            raycaster.set(new THREE.Vector3(x, RAY_START_H, z), DOWN);

            // pull out each tile's mesh, filter out anything falsy
            const meshes = Array.from(tileManager.tiles.values())
                .map(({ grid }) => grid && grid.mesh)
                .filter(Boolean);

            const inter = raycaster.intersectObjects(meshes, true);
            return inter.length > 0
                ? inter[0].point.y
                : dolly.position.y;
        }

        function snapDolly() {
            const { x, z } = dolly.position;
            dolly.position.y = getHeightAt(x, z) + EYE_HEIGHT;
        }



        function updateLocalMovement(delta) {
            const baseSpeed = 2.0;

            // camera axes
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            // corrected right vector: forward × up
            const right = new THREE.Vector3()
                .crossVectors(forward, new THREE.Vector3(0, 1, 0))
                .normalize();

            // keyboard inputs
            let moveX = 0, moveZ = 0;
            if (movement.forward) moveZ += 1;
            if (movement.backward) moveZ -= 1;
            if (movement.left) moveX -= 1;
            if (movement.right) moveX += 1;

            // add slide vector
            moveX += slideVector.x * slideMagnitude;
            moveZ += -slideVector.y * slideMagnitude;

            const combined = new THREE.Vector3()
                .addScaledVector(right, moveX)
                .addScaledVector(forward, moveZ);

            if (combined.lengthSq() > 0) {
                // speed scales with vector length
                const speed = baseSpeed * combined.length();
                combined.normalize().multiplyScalar(speed * delta);

                dolly.position.add(combined);
                snapDolly();

                // defer tile spawn until after render
                pendingTileSpawn = true;

                // broadcast movement/look
                broadcastPosition();
            }
        }


        // ── Signaling ───────────────────────────────────────────────────────────
        function attemptDefaultConnect() {
            socket = io(DEFAULT_SERVER, { transports: ['websocket'], timeout: 5000 });
            setupSocketEvents();
            socket.on('connect', () => { hideModal(); broadcastPosition(); });
            socket.on('connect_error', () => showModal());
        }
        function startWithUrl(url) {
            socket = io(url, { transports: ['websocket'], timeout: 5000 });
            setupSocketEvents();
            socket.on('connect', () => { hideModal(); broadcastPosition(); });
            socket.on('connect_error', () => { alert('Could not connect to ' + url); showModal(); });
        }
        function showModal() {
            document.getElementById('modal').classList.add('show');
            document.getElementById('connectBtn').onclick = () => {
                const u = document.getElementById('serverUrl').value.trim();
                if (!u) return alert('Enter a URL');
                startWithUrl(u);
            };
        }
        function hideModal() {
            document.getElementById('modal').classList.remove('show');
        }
        function setupSocketEvents() {
            socket.on('existing-peers', peers => peers.forEach(p => addPeer(p.id)));
            socket.on('new-peer', p => addPeer(p.id));
            socket.on('peer-disconnect', id => removePeer(id));
            socket.on('peer-message', data => {
                const pb = peerBalls[data.peerId]; if (!pb) return;
                try {
                    const m = JSON.parse(data.message);
                    pb.targetPos.set(m.x, m.y + EYE_HEIGHT, m.z);
                    pb.targetDir.set(m.dx, m.dy, m.dz);
                } catch { }
            });
        }
        function broadcastPosition() {
            if (socket && socket.connected) {
                const p = dolly.position, d = new THREE.Vector3();
                camera.getWorldDirection(d);
                socket.emit('broadcast-message', {
                    message: JSON.stringify({
                        x: p.x, y: p.y - EYE_HEIGHT, z: p.z,
                        dx: d.x, dy: d.y, dz: d.z
                    })
                });
            }
        }
        function addPeer(id) {
            if (peerBalls[id]) return;
            const color = Math.random() * 0xffffff;
            const mat = new THREE.MeshStandardMaterial({ color });
            const sph = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), mat);
            const arr = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, 0),
                0.2, color
            );
            const g = new THREE.Group();
            g.add(sph, arr);

            peerBalls[id] = {
                group: g,
                arrow: arr,
                targetPos: new THREE.Vector3(),
                targetDir: new THREE.Vector3(),
                currentDir: new THREE.Vector3(0, 0, 1)
            };
            scene.add(g);
        }

        function updatePeers() {
            Object.values(peerBalls).forEach(pb => {
                // smooth position
                pb.group.position.lerp(pb.targetPos, 0.1);
                // stick to terrain
                pb.group.position.y =
                    getHeightAt(pb.group.position.x, pb.group.position.z) + EYE_HEIGHT;

                // smooth look-direction
                const desired = pb.targetDir.clone().normalize();
                pb.currentDir.lerp(desired, 0.1);
                pb.arrow.setDirection(pb.currentDir);
            });
        }
        function removePeer(id) {
            const pb = peerBalls[id]; if (!pb) return;
            scene.remove(pb.group); delete peerBalls[id];
        }
    </script>
</body>

</html>
