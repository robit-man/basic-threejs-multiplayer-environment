<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>XR + Desktop + Mobile Nav Demo</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #111a;
            color: #eeea;
            font-family: monospace;
        }

        #hint {
            border-radius: 2rem;
            position: fixed;
            top: 1rem;
            left: 1rem;
            font-size: .75rem;
            background: rgba(0, 0, 0, 0.5);
            padding: .5em 1em;
            pointer-events: none;
        }

        #curHash {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            border-radius: 2rem;

            font-size: .75rem;
            background: rgba(0, 0, 0, 0.5);
            padding: .5em 1em;
            pointer-events: none;
        }

        #request,
        #geo {
            /* <── changed line */
            background: black;
            cursor: pointer;
            border: none;
            position: fixed;
            top: 1rem;
            border-radius: 2rem;
            width: 4rem;
            height: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            padding: 0.5rem;
        }

        /* small offset so buttons sit side-by-side (geo = left of request) */
        #geo {
            right: 1rem;
        }

        /* 4 rem width + 1.5 rem gap */
        #request {
            right: 5.5rem;
        }
    </style>
</head>

<body>
    <div id="hint">Click to lock • Arrows/WASD/Shift/run • Space/jump • Ctrl/crouch • Touch drag/look</div>
    <button id="request">
        <svg xmlns="http://www.w3.org/2000/svg" width="2rem" height="2rem" viewBox="0 0 24 24" fill="none">
            <path
                d="M12 18H12.01M9.2 21H14.8C15.9201 21 16.4802 21 16.908 20.782C17.2843 20.5903 17.5903 20.2843 17.782 19.908C18 19.4802 18 18.9201 18 17.8V6.2C18 5.0799 18 4.51984 17.782 4.09202C17.5903 3.71569 17.2843 3.40973 16.908 3.21799C16.4802 3 15.9201 3 14.8 3H9.2C8.0799 3 7.51984 3 7.09202 3.21799C6.71569 3.40973 6.40973 3.71569 6.21799 4.09202C6 4.51984 6 5.07989 6 6.2V17.8C6 18.9201 6 19.4802 6.21799 19.908C6.40973 20.2843 6.71569 20.5903 7.09202 20.782C7.51984 21 8.07989 21 9.2 21Z"
                stroke="#eeeeeeaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
    </button>
    <button id="geo">
        <!-- simple location-pin icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="2rem" height="2rem" viewBox="0 0 24 24" fill="none">
            <path d="M12 2C8.686 2 6 4.686 6 8c0 5.25 6 12 6 12s6-6.75 6-12c0-3.314-2.686-6-6-6Z" stroke="#eeeeeeaa"
                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            <circle cx="12" cy="8" r="2.5" fill="#eeeeeeaa" />
        </svg>
    </button>

    <div id="clearCacheBtn" style="position:absolute;top:1.5rem;left:10px;
    height:2rem;width:2rem;display:flex;
    align-items:center;justify-content:center;
    padding:0.5rem;border-radius:100%;background:#222;
    color:#fffa;cursor:pointer;z-index:9999;
    font-family:sans-serif;font-size:0.9rem;
    user-select:none;">
        <svg xmlns="http://www.w3.org/2000/svg" width="1rem" height="1rem" viewBox="0 0 24 24" fill="none">
            <path
                d="M3 3V8M3 8H8M3 8L6 5.29168C7.59227 3.86656 9.69494 3 12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.71683 21 4.13247 18.008 3.22302 14"
                stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </svg>

    </div>
    <div id="curHash">
        --
    </div>
    <div id="peerList" style="
    position: fixed;
    bottom: 1rem;
    left: 1rem;
    max-height: 30%;
    overflow-y: auto;
    background: rgba(0,0,0,0.5);
    padding: .5em 1em;
    border-radius: 1em;
    font-size: .75rem;
">
        <strong>Peers:</strong>
        <ul id="peerListUL" style="margin: .5em 0 0 0; padding: 0; list-style: none;"></ul>
    </div>


    <script type="importmap">
{
  "imports": {
    "three"                      : "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.min.js",
    "VRButton"                   : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/webxr/VRButton.js",
    "XRControllerModelFactory"   : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/webxr/XRControllerModelFactory.js",
    "PointerLockControls"        : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/controls/PointerLockControls.js",
    "EffectComposer"             : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/postprocessing/EffectComposer.js",
    "RenderPass"                 : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/postprocessing/RenderPass.js",
    "ShaderPass"                 : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/postprocessing/ShaderPass.js",
    "HorizontalTiltShiftShader"  : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/shaders/HorizontalTiltShiftShader.js",
    "VerticalTiltShiftShader"    : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/shaders/VerticalTiltShiftShader.js",
    "lz-string"                  : "https://cdn.jsdelivr.net/npm/lz-string@1.4.4/+esm",
    "socket.io"                  : "https://cdn.jsdelivr.net/npm/socket.io-client@4.5.4/dist/socket.io.esm.min.js",
    "gltfloader"                 : "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/loaders/GLTFLoader.js"
  }
}
</script>


    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'VRButton';
        import { XRControllerModelFactory } from 'XRControllerModelFactory';
        import { PointerLockControls } from 'PointerLockControls';
        import { GLTFLoader } from 'gltfloader';
        import LZString from 'lz-string';
        import { io } from 'socket.io';

        import { EffectComposer } from 'EffectComposer';
        import { RenderPass } from 'RenderPass';
        import { ShaderPass } from 'ShaderPass';
        import { HorizontalTiltShiftShader } from 'HorizontalTiltShiftShader';
        import { VerticalTiltShiftShader } from 'VerticalTiltShiftShader';


        document.getElementById('clearCacheBtn').onclick = () => {
            localStorage.clear();
            location.reload();
        };



        const CHARACTER_MODEL = '/Xbot.glb';
        const SIGNALING_SERVER = 'https://ipfs-signaling-vr.loca.lt';
        // point this at your LocalTunnel socket URL:
        const elevSocket = io('https://elevationpubquery.loca.lt', {
            transports: ['websocket']
        });
        const c16 = LZString.compressToUTF16;
        const d16 = LZString.decompressFromUTF16;

        const DIRS = [[1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]];
        const BUCKET_SIZE = 50;                // color‐bucket height in meters
        const TILE_CACHE_SAVE_INTERVAL = 100;  // ms between localStorage commits

        const Geohash = (() => {
            const BASE32 = "0123456789bcdefghjkmnpqrstuvwxyz";

            /**
             * Encode latitude and longitude into a geohash string.
             * @param {number} latitude  - latitude in degrees
             * @param {number} longitude - longitude in degrees
             * @param {number} [precision=7] - number of characters in resulting geohash
             * @returns {string} the geohash
             */
            function encode(latitude, longitude, precision = 7) {
                let isEven = true;
                let bit = 0;
                let ch = 0;
                let geohash = "";

                let latMin = -90.0, latMax = 90.0;
                let lonMin = -180.0, lonMax = 180.0;

                while (geohash.length < precision) {
                    if (isEven) {
                        // refine longitude interval
                        const mid = (lonMin + lonMax) / 2;
                        if (longitude >= mid) {
                            ch |= 1 << (4 - bit);
                            lonMin = mid;
                        } else {
                            lonMax = mid;
                        }
                    } else {
                        // refine latitude interval
                        const mid = (latMin + latMax) / 2;
                        if (latitude >= mid) {
                            ch |= 1 << (4 - bit);
                            latMin = mid;
                        } else {
                            latMax = mid;
                        }
                    }

                    isEven = !isEven;

                    if (bit < 4) {
                        bit++;
                    } else {
                        // 5 bits accumulated, map to base32 char
                        geohash += BASE32[ch];
                        bit = 0;
                        ch = 0;
                    }
                }

                return geohash;
            }

            return { encode };
        })();
        // --- Utilities for hex grid & elevation caching ---
        class Utils {
            static smoothstep(t) {
                return t * t * (3 - 2 * t);
            }
            static compress(json) {
                return LZString.compressToUTF16(json);
            }
            static decompress(comp) {
                return LZString.decompressFromUTF16(comp);
            }
        }

        // ─── PeerManager: handles socket connection, broadcasting, and remote peers ─────────────────
        class PeerManager {
            constructor(serverUrl, scene, dolly, camera, hexGridMgr) {
                this.scene = scene;
                this.dolly = dolly;
                this.camera = camera;
                this.hexGrid = hexGridMgr;
                this.socket = io(serverUrl, { transports: ['websocket'] });

                // **NEW** handle our peer‐list UI
                this.peerListEl = document.getElementById('peerListUL');
                // map of peerId → { group, arrow, targetPos, targetDir, currentDir }
                this.peers = {};

                // socket handlers
                this.socket.on('connect', () => this.broadcastPose());
                this.socket.on('existing-peers', peers => peers.forEach(p => this._addPeer(p.id)));
                this.socket.on('new-peer', peer => this._addPeer(peer.id));
                this.socket.on('peer-disconnect', id => this._removePeer(id));
                this.socket.on('peer-message', data => {
                    const pb = this.peers[data.peerId];
                    if (!pb) return;
                    const m = JSON.parse(data.message);
                    pb.targetPos.set(m.x, m.y + this.hexGrid.tileRadius, m.z);
                    pb.targetDir.set(m.dx, m.dy, m.dz);
                });
            }

            broadcastPose() {
                if (!this.socket.connected) return;
                const p = this.dolly.position.clone();
                const d = new THREE.Vector3();
                this.camera.getWorldDirection(d);
                this.socket.emit('broadcast-message', {
                    message: JSON.stringify({
                        x: p.x, y: p.y - this.hexGrid.tileRadius, z: p.z,
                        dx: d.x, dy: d.y, dz: d.z
                    })
                });
            }
            /*
            _addPeer(id) {
                if (this.peers[id]) return;
                const color = Math.random() * 0xffffff;
                const sph = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 12, 8),
                    new THREE.MeshStandardMaterial({ color })
                );
                const arr = new THREE.ArrowHelper(
                    new THREE.Vector3(0, 0, 1),
                    new THREE.Vector3(),
                    0.2, color
                );
                const grp = new THREE.Group();
                grp.add(sph, arr);
                this.scene.add(grp);
                this.peers[id] = {
                    group: grp,
                    arrow: arr,
                    targetPos: new THREE.Vector3(),
                    targetDir: new THREE.Vector3(),
                    currentDir: new THREE.Vector3(0, 0, 1)
                };
                // **NEW** add to the DOM list
                const li = document.createElement('li');
                li.id = `peer-${id}`;
                li.textContent = id;
                li.style.padding = '0.2em 0';
                this.peerListEl.appendChild(li);
                this.peers[id].listItem = li;
            }
*/
            _addPeer(id) {
                if (this.peers[id]) return;

                // 1) Instantiate the remote player
                const remote = new RemotePlayer(id, this.scene, this.hexGrid);
                this.peers[id] = remote;

                // 2) Add them to the on-screen peer list
                const li = document.createElement('li');
                li.id = `peer-${id}`;
                li.textContent = id;
                li.style.padding = '0.2em 0';
                this.peerListEl.appendChild(li);

                // 3) Keep a reference so we can remove it later
                remote.listItem = li;
            }

            _removePeer(id) {
                const remote = this.peers[id];
                if (!remote) return;

                // 1) Remove the GLTF model (not `.group`)
                if (remote.model) {
                    this.scene.remove(remote.model);
                }

                // 2) Remove their list entry
                if (remote.listItem) {
                    remote.listItem.remove();
                }

                // 3) Clean up our map
                delete this.peers[id];
            }

            /*
                        updatePeers() {
                            Object.values(this.peers).forEach(pb => {
                                // smooth position
                                pb.group.position.lerp(pb.targetPos, 0.1);
                                // stick to terrain
                                const h = this.hexGrid.getHeightAt(pb.group.position.x, pb.group.position.z);
                                pb.group.position.y = h + 3.2;
            
                                // smooth direction
                                const desired = pb.targetDir.clone().normalize();
                                pb.currentDir.lerp(desired, 0.1);
                                pb.arrow.setDirection(pb.currentDir);
                            });
                        }
                            */
            updatePeers(delta) {
                Object.values(this.peers).forEach(remote => {
                    remote.update(delta);
                });
            }

        }
        // ── after ── RemotePlayer with upright yaw + walk/run blending ───────────
        class RemotePlayer {
            constructor(id, scene, hexGrid) {
                this.id = id;
                this.scene = scene;
                this.hexGrid = hexGrid;
                this.loader = new GLTFLoader();
                this.model = null;
                this.mixer = null;
                this.actions = {};
                this.targetPos = new THREE.Vector3();
                this.targetDir = new THREE.Vector3();
                this.currentDir = new THREE.Vector3(0, 0, 1);
                this.currentAction = 'idle';
                this.speedHistory = [];
                this.maxSpeedSamples = 10;
                this._loadModel();
            }

            _loadModel() {
                this.loader.load(
                    CHARACTER_MODEL,
                    gltf => {
                        console.log(`RemotePlayer ${this.id} loaded`, gltf);

                        this.model = gltf.scene;
                        this.model.traverse(o => {
                            if (o.isMesh) o.castShadow = true;
                        });
                        this.scene.add(this.model);

                        this.mixer = new THREE.AnimationMixer(this.model);
                        gltf.animations.forEach(clip => {
                            const action = this.mixer.clipAction(clip);
                            action.enabled = true;
                            this.actions[clip.name] = action;
                        });

                        // kick off idle
                        this.actions.idle?.play();
                    },
                    undefined,
                    err => console.error(`Failed loading ${this.id}:`, err)
                );
            }

            update(delta) {
                if (!this.model || !this.mixer) return;

                // 1) advance animations
                this.mixer.update(delta);

                // 2) smooth X/Z toward targetPos
                this.model.position.x = THREE.MathUtils.lerp(
                    this.model.position.x, this.targetPos.x, 0.1
                );
                this.model.position.z = THREE.MathUtils.lerp(
                    this.model.position.z, this.targetPos.z, 0.1
                );

                // 3) snap Y to terrain + eye-height
                const h = this.hexGrid.getHeightAt(
                    this.model.position.x, this.model.position.z
                );
                const CHARACTER_EYE_HEIGHT = 1.6;
                this.model.position.y = h + CHARACTER_EYE_HEIGHT;

                // 4) upright yaw only, based on targetDir
                const flatDir = this.targetDir.clone().setY(0).normalize();
                const yaw = Math.atan2(flatDir.x, flatDir.z);
                this.model.rotation.set(0, yaw, 0);

                // 5) compute instantaneous speed (m/s)
                const diff = new THREE.Vector3().subVectors(
                    this.targetPos, this.model.position
                );
                const instantSpeed = diff.length() / (delta || 1);

                // 6) update moving average buffer
                this.speedHistory.push(instantSpeed);
                if (this.speedHistory.length > this.maxSpeedSamples) {
                    this.speedHistory.shift();
                }
                const avgSpeed = this.speedHistory.reduce((sum, v) => sum + v, 0)
                    / this.speedHistory.length;

                // — log UUID + averaged speed
                //console.log(`RemotePlayer ${this.id} avg speed: ${avgSpeed.toFixed(2)} m/s`);

                // 7) determine forward vs backward
                const forward = new THREE.Vector3(0, 0, 1)
                    .applyEuler(this.model.rotation);
                const movementDir = diff.clone().normalize();
                const dot = forward.dot(movementDir); // >0 forward, <0 backward

                // 8) pick action based on avgSpeed
                const WALK_SPEED = 15;  // m/s
                const RUN_SPEED = 25;  // m/s
                let next = 'idle';
                if (avgSpeed > RUN_SPEED) next = 'run';
                else if (avgSpeed > WALK_SPEED) next = 'walk';

                // 9) cross-fade & set timeScale for direction
                if (next !== this.currentAction) {
                    this.actions[this.currentAction]?.fadeOut(0.2);
                    const act = this.actions[next];
                    if (act) {
                        act.reset();
                        act.timeScale = dot >= 0 ? 1 : -1;
                        act.fadeIn(0.2).play();
                    }
                    this.currentAction = next;
                } else if (next === 'walk' || next === 'run') {
                    this.actions[next].timeScale = dot >= 0 ? 1 : -1;
                }
            }
        }

        class UniformHexGrid {
            constructor(spacing = 1, size = 100) {
                this.spacing = spacing;
                this.radius = size / 2;
                this._rings();
                this._geom();
                this._mesh();
            }

            _rings() {
                const s = this.spacing, h = Math.sqrt(3) / 2 * s,
                    N = Math.floor(this.radius / s);
                this.pos = [];
                this.tri = [];
                const map = {}, verts = [];
                let idx = 0;
                for (let j = -N; j <= N; j++) {
                    for (let i = -N; i <= N; i++) {
                        if (Math.max(Math.abs(i), Math.abs(j), Math.abs(i + j)) > N) continue;
                        const x = (i + j / 2) * s, z = j * h;
                        map[`${i},${j}`] = idx++;
                        verts.push(x, 0, z);
                    }
                }
                this.pos = verts;
                for (let j = -N; j < N; j++) {
                    for (let i = -N; i < N; i++) {
                        const a = map[`${i},${j}`],
                            b = map[`${i + 1},${j}`],
                            c = map[`${i},${j + 1}`],
                            d = map[`${i + 1},${j + 1}`];
                        if (a != null && b != null && c != null) this.tri.push(a, b, c);
                        if (b != null && d != null && c != null) this.tri.push(b, d, c);
                    }
                }
            }

            _geom() {
                // Positions
                const posAttr = new THREE.Float32BufferAttribute(
                    new Float32Array(this.pos), 3
                ).setUsage(THREE.DynamicDrawUsage);

                const vCount = this.pos.length / 3;
                // Color and alpha per vertex
                const cols = new Float32Array(vCount * 3);
                const alphas = new Float32Array(vCount);
                for (let i = 0; i < vCount; i++) {
                    cols[3 * i] = cols[3 * i + 1] = cols[3 * i + 2] = 0.5; // mid-gray
                    alphas[i] = 0.2;                                        // mostly transparent
                }

                this.geometry = new THREE.BufferGeometry();
                this.geometry.setAttribute('position', posAttr);
                this.geometry.setAttribute('color',
                    new THREE.Float32BufferAttribute(cols, 3)
                        .setUsage(THREE.DynamicDrawUsage)
                );
                this.geometry.setAttribute('alpha',
                    new THREE.Float32BufferAttribute(alphas, 1)
                        .setUsage(THREE.DynamicDrawUsage)
                );
                this.geometry.setIndex(this.tri);
                this.geometry.computeVertexNormals();
                this.geometry.computeBoundingSphere();
            }
            _mesh() {
                // keep your existing alpha & color attributes from _geom
                const shaderMat = new THREE.ShaderMaterial({
                    vertexColors: true,
                    transparent: true,
                    blending: THREE.NormalBlending,
                    depthWrite: false,
                    side: THREE.DoubleSide,

                    uniforms: {
                        colorLow: { value: new THREE.Color(0x111111) },
                        colorHigh: { value: new THREE.Color(0x555555) },
                        textureIntensity: { value: 0.5 }
                    },

                    vertexShader: `
            attribute float alpha;
            varying float vAlpha;
            varying vec3 vColor;     // holds grayscale t
            varying vec3 vWorldPos;
            void main() {
                vAlpha   = alpha;
                vColor   = color;      // recolorTile wrote t into color.rgb
                vec4 wp  = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `,
                    fragmentShader: `
            uniform vec3 colorLow;
            uniform vec3 colorHigh;
            uniform float textureIntensity;
            varying float vAlpha;
            varying vec3 vColor;
            varying vec3 vWorldPos;

            // simple pseudo‐random
            float rand(vec2 co){
                return fract(sin(dot(co,vec2(12.9898,78.233))) * 43758.5453);
            }

            void main(){
                if (vAlpha < 0.02) discard;
                // t = [0..1] from grayscale vertex color
                float t = vColor.r;
                // base gradient
                vec3 base = mix(colorLow, colorHigh, smoothstep(0.0,1.0,t));
                // add tiny static noise
                float noise = rand(vWorldPos.xz * 0.1);
                base += (noise - 0.5) * textureIntensity;
                gl_FragColor = vec4(base, vAlpha);
            }
        `
                });

                // wireframe overlay (unchanged)
                const wire = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.05,
                    wireframe: true
                });

                this.mesh = new THREE.Mesh(this.geometry, shaderMat);
                this.mesh.frustumCulled = false;

                const wMesh = new THREE.Mesh(this.geometry, wire);
                wMesh.frustumCulled = false;
                wMesh.renderOrder = 1;

                this.group = new THREE.Group();
                this.group.add(this.mesh, wMesh);
            }



            get object() {
                return this.group;
            }
        }


        class TileManager {
            constructor(scene, spacing = 5, tileRadius = 50, elevSocket) {
                this.scene = scene;
                this.spacing = spacing;
                this.tileRadius = tileRadius;
                this.tiles = new Map();    // id → { grid, q, r, elevArr, fetched, populating }
                this.origin = null;         // set on first gps‐updated
                this.elevCache = this._loadCache();
                this.elevSocket = elevSocket;
                this.ray = new THREE.Raycaster();
                this.DOWN = new THREE.Vector3(0, -1, 0);


                // basic lighting
                if (!scene.userData._tmLightsAdded) {
                    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                    const dl = new THREE.DirectionalLight(0xffffff, 0.6);
                    dl.position.set(50, 100, 50);
                    dl.castShadow = true;
                    scene.add(dl);
                    scene.userData._tmLightsAdded = true;
                }

                // shared material
                if (!TileManager.sharedMat) {
                    TileManager.sharedMat = new THREE.MeshStandardMaterial({
                        vertexColors: true,
                        flatShading: true,
                        metalness: 0.2,
                        roughness: 0.8,
                        side: THREE.DoubleSide
                    });
                }

                // wait for GPS fix
                const saved = localStorage.getItem('tmOrigin');
                if (saved) {
                    this.origin = JSON.parse(saved);
                    this.addTile(0, 0);
                } else {
                    document.addEventListener('gps-updated', e => {
                        if (!this.origin) {
                            this.origin = e.detail;
                            // persist for future page loads or late events
                            localStorage.setItem('tmOrigin', JSON.stringify(this.origin));
                            this.addTile(0, 0);
                        }
                    }, { once: true });
                }


                if (!TileManager._tmpV) TileManager._tmpV = new THREE.Vector3();
                this._lastHeight = 0;

                //this.addTile(0, 0);
            }

            static minY = Infinity;
            static maxY = -Infinity;
            static _globalRecolorPending = false;

            // schedule a full‐scene recolor next frame
            _scheduleGlobalRecolor() {
                if (TileManager._globalRecolorPending) return;
                TileManager._globalRecolorPending = true;
                requestAnimationFrame(() => {
                    for (const { grid } of this.tiles.values()) {
                        this._recolorTile(grid);
                    }
                    TileManager._globalRecolorPending = false;
                });
            }

            // public: sample terrain height
            getHeightAt(x, z) {
                // 1) pick a start‐height well above your highest tile
                const top = Math.max(TileManager.maxY + 10, this.tileRadius * 2 + 10);
                TileManager._tmpV.set(x, top, z);

                // 2) cast straight down
                this.ray.set(TileManager._tmpV, this.DOWN);
                // optional: limit far if you like
                this.ray.far = top + this.tileRadius * 2;

                // 3) gather all terrain meshes (use the groups so you don't miss anything)
                const meshes = Array.from(this.tiles.values()).map(d => d.grid.group);
                const hits = this.ray.intersectObjects(meshes, true);

                if (hits.length) {
                    this._lastHeight = hits[0].point.y;
                }
                return this._lastHeight;
            }


            // called each frame with player position
            update(playerPos) {
                if (!this.origin) return;
                const a = this.tileRadius;
                const qf = (2 / 3 * playerPos.x) / a;
                const rf = ((-1 / 3 * playerPos.x) + (Math.sqrt(3) / 3 * playerPos.z)) / a;
                const q0 = Math.round(qf), r0 = Math.round(rf);
                const dq = qf - q0, dr = rf - r0, ds = -dq - dr;
                const dist = Math.max(Math.abs(dq), Math.abs(dr), Math.abs(ds)) * a;
                if (dist < 15) return;

                // choose 1–2 directions to expand
                const dots = DIRS
                    .map(([dx, dy]) => ({ dir: [dx, dy], dot: dq * dx + dr * dy }))
                    .sort((a, b) => b.dot - a.dot);

                const toAdd = [dots[0].dir];
                if (dots[1].dot > 0.5 * dots[0].dot) toAdd.push(dots[1].dir);

                for (const [dx, dy] of toAdd) {
                    const nq = q0 + dx, nr = r0 + dy;
                    this._ensureTile(nq, nr);
                    DIRS.forEach(([dx2, dy2]) => this._ensureTile(nq + dx2, nr + dy2));
                }
            }

            // ensure tile exists, bump LRU, recolor on recall
            _ensureTile(q, r) {
                const id = `${q},${r}`;
                if (this.tiles.has(id)) {
                    // bump to most‐recent
                    const entry = this.tiles.get(id);
                    this.tiles.delete(id);
                    this.tiles.set(id, entry);
                    // immediately recolor recalled tile (and neighbors)
                    this._scheduleGlobalRecolor();
                } else {
                    this.addTile(q, r);
                }
                // prune oldest if over 100
                while (this.tiles.size > 800) {
                    const oldest = this.tiles.keys().next().value;
                    this._disposeTile(oldest);
                }
            }

            async addTile(q, r) {
                const id = `${q},${r}`;
                const grid = new UniformHexGrid(this.spacing, this.tileRadius * 2);
                grid.id = id;
                grid.group.name = `tile-${id}`;

                // 1) position & basic setup
                const a = this.tileRadius;
                grid.group.position.set(
                    1.5 * a * q,
                    0,
                    a * (Math.sqrt(3) / 2 * q + Math.sqrt(3) * r)
                );
                const geom = grid.geometry;
                if (!geom.attributes.color) {
                    const arr = new Float32Array(geom.attributes.position.count * 3);
                    geom.setAttribute('color', new THREE.BufferAttribute(arr, 3));
                }
                grid.mesh.material = TileManager.sharedMat;

                // 2) seed height from neighbor averages
                let sum = 0, cnt = 0;
                for (const [dx, dy] of DIRS) {
                    const nb = this.tiles.get(`${q + dx},${r + dy}`);
                    if (nb && Number.isFinite(nb.grid.avgHeight)) {
                        sum += nb.grid.avgHeight;
                        cnt++;
                    }
                }
                const seedH = cnt ? sum / cnt : 0;
                const pos = geom.attributes.position;
                for (let i = 0; i < pos.count; i++) pos.setY(i, seedH);
                pos.needsUpdate = true;

                // 3) prepare tile state & compute neighbor-lists once
                const elevArr = Array(pos.count).fill(null);
                const fetched = new Set();
                // build triangle adjacency map
                const idxArr = geom.index.array;
                const neighbors = Array.from({ length: pos.count }, () => []);
                for (let t = 0; t < idxArr.length; t += 3) {
                    const [aI, bI, cI] = [idxArr[t], idxArr[t + 1], idxArr[t + 2]];
                    neighbors[aI].push(bI, cI);
                    neighbors[bI].push(aI, cI);
                    neighbors[cI].push(aI, bI);
                }
                // stash for use in _populate
                this.tiles.set(id, { grid, q, r, elevArr, fetched, populating: false, neighbors });

                // 4) inject into scene immediately (edges will auto-mate)
                this.scene.add(grid.group);

                // 5) kick off async filling
                setTimeout(() => this._populate(id), 0);
            }

            /** Persist current elevArr + fetched set to localStorage */
            _cacheTileProgress(id) {
                const data = this.tiles.get(id);
                if (!data) return;
                const { elevArr, fetched } = data;
                localStorage.setItem(
                    `tile:${id}`,
                    JSON.stringify({
                        elevArr,
                        fetched: Array.from(fetched)
                    })
                );
            }

            // ─── Replacement for _populate ─────────────────────────────────────
            _populate = function (id) {
                const data = this.tiles.get(id);
                if (!data || !this.origin || data.populating || data.hasPopulated) return;
                data.populating = true;

                const { grid, elevArr, fetched, q, r, neighbors } = data;
                const pos = grid.geometry.attributes.position;
                const n = pos.count;

                const STEP = 5;
                const SMOOTH_PASSES = 5;
                const MAX_CON = 50;
                const mLat = 111320;
                const mLon = 111320 * Math.cos(this.origin.lat * Math.PI / 180);

                // 1) Smoothing helper
                const smoothInterior = () => {
                    const fetchedPts = Array.from(fetched).map(i => ({
                        x: grid.group.position.x + pos.getX(i),
                        z: grid.group.position.z + pos.getZ(i),
                        y: pos.getY(i)
                    }));
                    for (let pass = 0; pass < SMOOTH_PASSES; pass++) {
                        const snap = new Float32Array(n);
                        for (let k = 0; k < n; k++) snap[k] = pos.getY(k);
                        for (let k = 0; k < n; k++) {
                            if (fetched.has(k)) continue;
                            let sum = 0, cnt = 0;
                            for (const nb of neighbors[k]) {
                                if (fetched.has(nb)) {
                                    sum += snap[nb];
                                    cnt++;
                                }
                            }
                            let newY = snap[k];
                            if (cnt > 0) {
                                newY = sum / cnt;
                            } else if (fetchedPts.length) {
                                const xk = grid.group.position.x + pos.getX(k),
                                    zk = grid.group.position.z + pos.getZ(k);
                                let wsum = 0, wden = 0;
                                for (const pt of fetchedPts) {
                                    const dx = pt.x - xk, dz = pt.z - zk;
                                    const d2 = dx * dx + dz * dz + 1e-6;
                                    const w = 1.0 / d2;
                                    wsum += w * pt.y;
                                    wden += w;
                                }
                                newY = wsum / wden;
                            }
                            pos.setY(k, snap[k] * 0.7 + newY * 0.3);
                        }
                    }
                    pos.needsUpdate = true;
                };

                // 2) Preload cache if present
                const raw = localStorage.getItem(`tile:${id}`);
                if (raw) {
                    try {
                        const obj = JSON.parse(raw);
                        obj.fetched.forEach(i => {
                            const v = obj.elevArr[i];
                            pos.setY(i, v);
                            elevArr[i] = v;
                            fetched.add(i);
                        });
                        pos.needsUpdate = true;
                        smoothInterior();
                        this._scheduleGlobalRecolor();
                    } catch {
                        localStorage.removeItem(`tile:${id}`);
                    }
                }

                // 3) Collect missing vertices
                let missing = [];
                for (let i = 0; i < n; i++) {
                    if (!fetched.has(i)) missing.push(i);
                }
                if (!missing.length) {
                    data.populating = false;
                    return this._finalizeTile(id);
                }

                // 4) Farthest-first + interleave into STEP groups
                missing = missing
                    .map(i => ({ i, d2: pos.getX(i) ** 2 + pos.getZ(i) ** 2 }))
                    .sort((a, b) => b.d2 - a.d2)
                    .map(o => o.i);
                const groups = Array.from({ length: STEP }, () => []);
                missing.forEach((i, idx) => groups[idx % STEP].push(i));

                // 5) Batched fetch with global lock
                if (!TileManager._fetching) TileManager._fetching = false;
                const fetchBatch = indices => new Promise(resolve => {
                    const toFetch = [];
                    indices.forEach(i => {
                        const wx = grid.group.position.x + pos.getX(i),
                            wz = grid.group.position.z + pos.getZ(i),
                            lat = this.origin.lat + wz / mLat,
                            lon = this.origin.lon + wx / mLon;
                        const cacheVal = this._elevCache(lat, lon);
                        if (cacheVal != null) {
                            pos.setY(i, cacheVal);
                            elevArr[i] = cacheVal;
                            fetched.add(i);
                        } else {
                            toFetch.push({ i, lat, lng: lon });
                        }
                    });

                    if (!toFetch.length) {
                        resolve();
                        return;
                    }

                    // wait for global lock
                    const startRequest = () => {
                        TileManager._fetching = true;
                        this.elevSocket.emit('elevation-request', {
                            dataset: 'mapzen',
                            locations: toFetch.map(o => ({ lat: o.lat, lng: o.lng }))
                        });
                        // no ack; listen once and then release lock
                        this.elevSocket.once('elevation-response', resp => {
                            const results = (resp && Array.isArray(resp.results)) ? resp.results : [];
                            toFetch.forEach(({ i, lat, lng }, idx) => {
                                const r = results[idx];
                                const v = (r && typeof r.elevation === 'number') ? r.elevation : 0;
                                pos.setY(i, v);
                                elevArr[i] = v;
                                fetched.add(i);
                                TileManager.minY = Math.min(TileManager.minY, v);
                                TileManager.maxY = Math.max(TileManager.maxY, v);
                                this._storeCache(lat, lng, v);
                            });
                            TileManager._fetching = false;
                            resolve();
                        });
                    };

                    if (!TileManager._fetching) {
                        startRequest();
                    } else {
                        const poll = () => {
                            if (!TileManager._fetching) startRequest();
                            else setTimeout(poll, 2);
                        };
                        poll();
                    }
                });

                // 6) Run all batches sequentially
                (async () => {
                    for (let pass = 0; pass < STEP; pass++) {
                        const batch = groups[pass];
                        for (let start = 0; start < batch.length; start += MAX_CON) {
                            await fetchBatch(batch.slice(start, start + MAX_CON));
                            smoothInterior();
                            this._scheduleGlobalRecolor();
                        }
                    }

                    // 7) Fill any remaining holes via neighbor-average
                    const still = [];
                    for (let i = 0; i < n; i++) {
                        if (!fetched.has(i)) still.push(i);
                    }
                    still.forEach(i => {
                        let sum = 0, cnt = 0;
                        for (const nb of neighbors[i]) {
                            if (fetched.has(nb)) { sum += pos.getY(nb); cnt++; }
                        }
                        if (cnt) {
                            const v = sum / cnt;
                            pos.setY(i, v);
                            elevArr[i] = v;
                            fetched.add(i);
                        }
                    });

                    // 8) One-way push to children only
                    for (const [dx, dy] of DIRS) {
                        if (this._isParentTile(q, r, dx, dy)) {
                            const nbrId = `${q + dx},${r + dy}`;
                            if (this.tiles.has(nbrId)) {
                                this._stitchEdges(id, nbrId);
                            }
                        }
                    }

                    smoothInterior();
                    this._scheduleGlobalRecolor();

                    data.populating = false;
                    data.hasPopulated = true;
                    this._finalizeTile(id);
                })();
            };



            _finalizeTile(id) {
                const data = this.tiles.get(id);
                if (!data) return;
                const { grid, elevArr, fetched, q, r } = data;

                // bake normals & static draw
                grid.geometry.computeVertexNormals();
                grid.geometry.attributes.position.setUsage(THREE.StaticDrawUsage);

                // compute average height
                grid.avgHeight = elevArr.reduce((s, v) => s + v, 0) / fetched.size;

                // push out only to “child” neighbors
                for (const [dx, dy] of DIRS) {
                    if (this._isParentTile(q, r, dx, dy)) {
                        const nbrId = `${q + dx},${r + dy}`;
                        if (this.tiles.has(nbrId)) {
                            this._stitchEdges(id, nbrId);
                        }
                    }
                }

                // cache & persist
                this._cacheTileProgress(id);
                localStorage.setItem(
                    `tile:${id}`,
                    JSON.stringify({ elevArr, fetched: Array.from(fetched) })
                );
            }




            _isParentTile(q, r, dq, dr) {
                const q2 = q + dq, r2 = r + dr;
                if (q !== q2) return q < q2;
                return r < r2;
            };
            _getSharedEdgePairs(idA, idB) {
                const dataA = this.tiles.get(idA), dataB = this.tiles.get(idB);
                const { grid: gA } = dataA, { grid: gB } = dataB;
                const posA = gA.geometry.attributes.position,
                    posB = gB.geometry.attributes.position;
                const mapA = new Map();
                for (let i = 0; i < posA.count; i++) {
                    const x = (gA.group.position.x + posA.getX(i)).toFixed(6),
                        z = (gA.group.position.z + posA.getZ(i)).toFixed(6);
                    mapA.set(`${x},${z}`, i);
                }
                const pairs = [];
                for (let j = 0; j < posB.count; j++) {
                    const x = (gB.group.position.x + posB.getX(j)).toFixed(6),
                        z = (gB.group.position.z + posB.getZ(j)).toFixed(6),
                        key = `${x},${z}`;
                    const i = mapA.get(key);
                    if (i !== undefined) pairs.push([i, j]);
                }
                return pairs;
            };
            _stitchEdges(id) {
                const dataA = this.tiles.get(id);
                if (!dataA) return;

                const { grid: gA, fetched: fetchedA, q, r } = dataA;
                const posA = gA.geometry.attributes.position;

                for (const [dq, dr] of DIRS) {
                    const nbrId = `${q + dq},${r + dr}`;
                    const dataB = this.tiles.get(nbrId);
                    if (!dataB) continue;

                    const { grid: gB, fetched: fetchedB } = dataB;
                    const posB = gB.geometry.attributes.position;

                    // find all matching world‐space vertices
                    const pairs = this._getSharedEdgePairs(id, nbrId);
                    for (const [i, j] of pairs) {
                        const hasA = fetchedA.has(i);
                        const hasB = fetchedB.has(j);

                        // if A has it but B doesn't, push A→B
                        if (hasA && !hasB) {
                            posB.setY(j, posA.getY(i));
                        }
                        // if B has it but A doesn't, pull B→A
                        else if (!hasA && hasB) {
                            posA.setY(i, posB.getY(j));
                        }
                        // if both or neither, leave as is
                    }

                    posB.needsUpdate = true;
                    gB.geometry.computeVertexNormals();
                }

                posA.needsUpdate = true;
                gA.geometry.computeVertexNormals();
            };


            // —––– 3) Replace your old _recolorTile(grid) with this —––—
            _recolorTile(grid) {
                const pos = grid.geometry.attributes.position;
                const col = grid.geometry.attributes.color;
                const alpha = grid.geometry.attributes.alpha;
                const n = pos.count;
                const minY = TileManager.minY, maxY = TileManager.maxY;
                const span = Math.max(1e-6, maxY - minY);

                // look up which verts have been fetched
                const fetched = this.tiles.get(grid.id).fetched;

                for (let i = 0; i < n; i++) {
                    const y = pos.getY(i);
                    const t = THREE.MathUtils.clamp((y - minY) / span, 0, 1);
                    // grayscale from black to white
                    col.setXYZ(i, t, t, t);
                    // alpha=1 for fetched, lower for averaged
                    alpha.setX(i, fetched.has(i) ? 1.0 : 0.2 + 0.8 * t);
                }

                col.needsUpdate = true;
                alpha.needsUpdate = true;
            }


            _disposeTile(id) {
                const { grid } = this.tiles.get(id);
                this.scene.remove(grid.group);
                grid.geometry.dispose();
                grid.mesh?.material.dispose();
                this.tiles.delete(id);
            }

            _loadCache() {
                try { return JSON.parse(localStorage.getItem('elevCacheV1')) || {}; }
                catch { return {}; }
            }

            _elevCache(lat, lon) {
                const k = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                return this.elevCache[k] ?? null;
            }

            _storeCache(lat, lon, v) {
                const k = `${lat.toFixed(6)},${lon.toFixed(6)}`;
                this.elevCache[k] = v;
                localStorage.setItem('elevCacheV1', JSON.stringify(this.elevCache));
            }
            getCurrentHash(playerPos, precision = 7) {
                if (!this.origin) return '';
                const a = this.tileRadius;
                // convert world x,z → fractional axial coords:
                const qf = (2 / 3 * playerPos.x) / a;
                const rf = ((-1 / 3 * playerPos.x) + (Math.sqrt(3) / 3 * playerPos.z)) / a;
                // round to nearest hex indices:
                const q0 = Math.round(qf), r0 = Math.round(rf);

                // compute that hex's center in world coords:
                const cx = 1.5 * a * q0;
                const cz = a * (Math.sqrt(3) / 2 * q0 + Math.sqrt(3) * r0);

                // convert back to lat/lon
                const mLat = 111320;
                const mLon = 111320 * Math.cos(this.origin.lat * Math.PI / 180);
                const lat = this.origin.lat + cz / mLat;
                const lon = this.origin.lon + cx / mLon;

                return Geohash.encode(lat, lon, precision);
            }

        }



        // --- Rest of app classes (Platform, SensorManager, SceneManager, etc.) ---
        class Platform {
            constructor() {
                this.isMobile = /Mobi|Android/i.test(navigator.userAgent);
            }
        }
        class GeoRequester {
            constructor(btn) {
                this.btn = btn;
                if (!('geolocation' in navigator)) {
                    btn.style.display = 'none';
                    console.warn('[GeoRequester] Geolocation API unavailable');
                    return;
                }
                btn.addEventListener('click', () => this._request(), { once: true });
            }

            _request() {
                const success = pos => {
                    const { latitude: lat, longitude: lon } = pos.coords;
                    document.dispatchEvent(new CustomEvent('gps-updated', { detail: { lat, lon } }));
                    navigator.geolocation.watchPosition(
                        p => {
                            const { latitude, longitude } = p.coords;
                            document.dispatchEvent(new CustomEvent('gps-updated', { detail: { lat: latitude, lon: longitude } }));
                        },
                        err => console.warn('[GeoRequester] watchPosition error', err),
                        { enableHighAccuracy: true, maximumAge: 5000, distanceFilter: 1 }
                    );
                    this.btn.disabled = true;
                };
                const fail = err => {
                    console.warn('[GeoRequester] getCurrentPosition failed', err);
                    /* allow retry */
                    this.btn.disabled = false;
                    this.btn.addEventListener('click', () => this._request(), { once: true });
                };
                this.btn.disabled = true;            // immediate visual feedback
                navigator.geolocation.getCurrentPosition(success, fail, { enableHighAccuracy: true });
            }
        }
        // REPLACE WITH ─ UnifiedSensorManager (VR-ready geo prompt + live orientation) ─
        class SensorManager {
            constructor(requestBtn, hintEl, platform) {
                this.requestBtn = requestBtn;
                this.hintEl = hintEl;
                this.platform = platform;

                /* show button only if any permission still needs a user gesture */
                this.needsGesture =
                    typeof DeviceOrientationEvent?.requestPermission === 'function' ||
                    typeof DeviceMotionEvent?.requestPermission === 'function';

                if (!this.needsGesture) {
                    /* desktop or already-granted → start immediately */
                    this.requestBtn.style.display = 'none';
                    this._enableAllSensors();
                } else {
                    /* mobile / VR browsers: wait for single tap */
                    this.requestBtn.addEventListener('click', () => this._enableAllSensors(), { once: true });
                }

                this.hintEl.textContent = 'Awaiting Sensor Permission • ' + this.hintEl.textContent;
            }

            /* ------------------------------------------------------------------ */
            async _enableAllSensors() {
                /* 1  Orientation / motion */
                try {
                    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                        const st = await DeviceOrientationEvent.requestPermission();
                        if (st !== 'granted') throw 'orientation denied';
                    }
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        const st = await DeviceMotionEvent.requestPermission();
                        if (st !== 'granted') throw 'motion denied';
                    }
                    window.addEventListener('deviceorientation', e => this._broadcastOrient(e), true);
                    window.addEventListener('devicemotion', () => { }, true); // (future use)
                } catch { console.warn('[SensorMgr] orientation/motion permission denied'); }

                /* 2  Geolocation – works on desktop, mobile, and VR browsers           */
                if (!('geolocation' in navigator)) {
                    console.warn('[SensorMgr] Geolocation API unavailable');
                } else {
                    /* query permission state so we know whether a prompt will appear      */
                    const perm = await (navigator.permissions?.query?.({ name: 'geolocation' }) ?? Promise.resolve({ state: 'prompt' }));
                    /* request once so the browser can prompt (VR headsets often need it) */
                    if (perm.state !== 'granted') {
                        try { await this._oneShotGeo(); } catch { /* prompt dismissed */ }
                    }
                    /* keep position flowing thereafter                                    */
                    navigator.geolocation.watchPosition(
                        p => this._broadcastGPS(p),
                        err => console.warn('[SensorMgr] watchPosition error', err),
                        { enableHighAccuracy: true, maximumAge: 5000, distanceFilter: 1 }
                    );
                }

                /* UI feedback */
                this.requestBtn.disabled = true;
                this.hintEl.textContent = 'Sensors Enabled • ' + this.hintEl.textContent;
            }

            /* helper – single getCurrentPosition to trigger browser prompt         */
            _oneShotGeo() {
                return new Promise((res, rej) => {
                    navigator.geolocation.getCurrentPosition(res, rej, { enableHighAccuracy: true });
                }).then(p => this._broadcastGPS(p));
            }

            _broadcastGPS(pos) {
                const { latitude: lat, longitude: lon } = pos.coords;
                document.dispatchEvent(new CustomEvent('gps-updated', { detail: { lat, lon } }));
            }

            _broadcastOrient(ev) {
                if (ev.alpha == null && ev.beta == null && ev.gamma == null) return;
                document.dispatchEvent(new CustomEvent('orientation-updated', {
                    detail: { alpha: ev.alpha ?? 0, beta: ev.beta ?? 0, gamma: ev.gamma ?? 0 }
                }));
            }
        }

        class SceneManager {
            constructor(platform) {
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.xr.enabled = true;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                document.body.appendChild(this.renderer.domElement);
                document.body.appendChild(VRButton.createButton(this.renderer));
                this.renderer.xr.addEventListener('sessionstart', () => {
                    document.getElementById('request').style.display = 'none';
                });

                // Scene + Fog
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x202020);
                this.scene.fog = new THREE.FogExp2(0x202020, 0.002);

                // Camera + Dolly
                this.camera = new THREE.PerspectiveCamera(
                    75, window.innerWidth / window.innerHeight, 0.05, 1000
                );
                this.camera.position.set(0, 1.6, 0);
                this.dolly = new THREE.Group();
                this.dolly.add(this.camera);
                this.scene.add(this.dolly);

                // Lighting
                const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(hemi);
                const sun = new THREE.DirectionalLight(0xffffff, 4.0);
                sun.position.set(100, 500, 100);
                sun.castShadow = true;
                sun.shadow.mapSize.set(2048, 2048);
                sun.shadow.camera.near = 0.5;
                sun.shadow.camera.far = 500;
                sun.shadow.camera.left = -200;
                sun.shadow.camera.right = 200;
                sun.shadow.camera.top = 200;
                sun.shadow.camera.bottom = -200;
                this.scene.add(sun);

                // Ground plane
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const ground = new THREE.Mesh(
                    new THREE.PlaneGeometry(1000, 1000),
                    groundMat
                );
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // ─── Post-processing: only when NOT in VR ────────────────────
                if (!this.renderer.xr.isPresenting) {
                    this.composer = new EffectComposer(this.renderer);
                    this.composer.addPass(new RenderPass(this.scene, this.camera));

                    this.hTilt = new ShaderPass(HorizontalTiltShiftShader);
                    this.hTilt.uniforms.h.value = 2 / window.innerHeight;
                    this.composer.addPass(this.hTilt);

                    this.vTilt = new ShaderPass(VerticalTiltShiftShader);
                    this.vTilt.uniforms.v.value = 1 / window.innerWidth;
                    this.composer.addPass(this.vTilt);
                } else {
                    this.composer = null;
                }

                // Handle resize
                window.addEventListener('resize', () => {
                    const w = window.innerWidth, h = window.innerHeight;
                    this.renderer.setSize(w, h);
                    this.camera.aspect = w / h;
                    this.camera.updateProjectionMatrix();

                    if (this.composer) {
                        this.composer.setSize(w, h);
                        this.hTilt.uniforms.h.value = 1 / h;
                        this.vTilt.uniforms.v.value = 1 / w;
                    }
                });
            }

            // single render entry-point
            render() {
                if (this.renderer.xr.isPresenting || !this.composer) {
                    // VR or no composer → standard render
                    this.renderer.render(this.scene, this.camera);
                } else {
                    // non-VR → post-process
                    this.composer.render();
                }
            }
        }



        class XRControllerManager {
            constructor(renderer, dolly) {
                const factory = new XRControllerModelFactory();
                renderer.xr.addEventListener('sessionstart', () => {
                    const c1 = renderer.xr.getController(0), c2 = renderer.xr.getController(1);
                    dolly.add(c1, c2);
                    const g1 = renderer.xr.getControllerGrip(0), g2 = renderer.xr.getControllerGrip(1);
                    g1.add(factory.createControllerModel(g1));
                    g2.add(factory.createControllerModel(g2));
                    dolly.add(g1, g2);
                });
            }
        }

        class InputManager {
            constructor(platform, renderer, controls, movement, slide, sensor) {
                this.platform = platform; this.renderer = renderer;
                this.controls = controls; this.movement = movement; this.slide = slide;
                document.body.addEventListener('click', () => {
                    if (!this.renderer.xr.isPresenting && !this.platform.isMobile) controls.lock();
                });
                controls.addEventListener('lock', () => document.getElementById('hint').textContent = 'Locked • Arrows/WASD');
                controls.addEventListener('unlock', () => document.getElementById('hint').textContent = 'Click to lock');
                window.addEventListener('keydown', e => this._onKey(e, true));
                window.addEventListener('keyup', e => this._onKey(e, false));
                window.addEventListener('touchstart', e => { this.touchStart = e.touches[0]; });
                window.addEventListener('touchmove', e => this._onTouch(e), { passive: false });
                window.addEventListener('touchend', () => {
                    this.touchStart = null;
                    /* keep the same object instance so MovementController sees the change */
                    this.slide.x = 0;
                    this.slide.y = 0;
                    this.slide.mag = 0;
                });
            }
            _onKey(e, down) {
                switch (e.code) {
                    case 'ArrowUp': case 'KeyW': this.movement.forward = down; break;
                    case 'ArrowDown': case 'KeyS': this.movement.backward = down; break;
                    case 'ArrowLeft': case 'KeyA': this.movement.left = down; break;
                    case 'ArrowRight': case 'KeyD': this.movement.right = down; break;
                    case 'ShiftLeft': case 'ShiftRight': this.movement.shift = down; break;
                    case 'ControlLeft': case 'ControlRight': this.movement.crouch = down; break;
                    case 'Space': if (down && this.movement.jumpState === 'idle') {
                        this.movement.jumpState = 'up'; this.movement.jumpTarget = this.movement.JUMP_Y;
                    } break;
                }
            }
            _onTouch(e) {
                if (!this.touchStart) return;
                const t = e.touches[0];
                let dx = t.clientX - this.touchStart.clientX, dy = t.clientY - this.touchStart.clientY;
                const mx = 200;
                dx = Math.max(-mx, Math.min(mx, dx));
                dy = Math.max(-mx, Math.min(mx, dy));
                this.slide.x = dx / mx; this.slide.y = dy / mx;
                this.slide.mag = Math.min(1, Math.hypot(this.slide.x, this.slide.y));
                e.preventDefault();
            }
        }

        class MovementController {
            constructor(sceneMgr, inputMgr, consts, platform) {
                this.dolly = sceneMgr.dolly;
                this.camera = sceneMgr.camera;
                this.renderer = sceneMgr.renderer;
                this.input = inputMgr.movement ? inputMgr.movement : inputMgr;
                this.slide = inputMgr.slide;
                this.consts = consts;
                this.platform = platform;

                /* ← mobile orientation payload comes from SensorManager */
                this.orientation = { alpha: 0, beta: 0, gamma: 0, ready: false };
                document.addEventListener('orientation-updated', e => {
                    Object.assign(this.orientation, e.detail, { ready: true });
                });
            }
            update(dt) {
                /* ------------------------- aliases / consts ------------------------- */
                const { FWD, RIGHT } = this.consts.vectors;
                const {
                    BASE_SPEED, YAW_SPEED, DEADZONE,
                    RUN_EASE, MIN_RUN, MAX_RUN,
                    CROUCH_EASE          // JUMP_EASE no longer needed for physics jump
                } = this.consts;
                const inp = this.input;          // shorthand
                const GRAV = 20;                  // “eye-units” · s⁻²  (tweak to taste)

                /* -------- one-time per-run initialisation of vertical state --------- */
                if (inp.eyeY === undefined) {
                    inp.baseEye = inp.STAND_Y;
                    inp.crouchEye = inp.CROUCH_Y;
                    inp.jumpPeak = inp.baseEye * 1.5;
                    inp.eyeY = inp.baseEye;
                    inp.vertVel = 0;             // current vertical velocity
                    inp.groundY = 0;             // updated by _snap()
                }

                /* ---------------- trigger: convert “up” into a real jump ------------ */
                if (inp.jumpState === 'up') {              // set by space-bar / R-stick
                    const h = inp.jumpPeak - inp.baseEye;
                    inp.vertVel = Math.sqrt(2 * GRAV * h);   // v₀ for that height
                    inp.jumpState = 'jumping';
                }

                /* --------------------------- vertical motion ------------------------ */
                if (inp.jumpState === 'jumping') {         // simple ballistic arc
                    inp.vertVel -= GRAV * dt;
                    inp.eyeY += inp.vertVel * dt;

                    /* landed?  clamp & finish */
                    if (inp.eyeY <= inp.baseEye) {
                        inp.eyeY = inp.baseEye;
                        inp.vertVel = 0;
                        inp.jumpState = 'idle';
                    }
                } else {                                   // stand / crouch easing
                    const tgt = inp.crouch ? inp.crouchEye : inp.baseEye;
                    inp.eyeY += (tgt - inp.eyeY) * Math.min(1, CROUCH_EASE * dt);
                }

                /* camera height = terrain + eye-offset */
                this.dolly.position.y = inp.groundY + inp.eyeY;

                /* --------------------------- VR locomotion -------------------------- */
                if (this.renderer.xr.isPresenting) {
                    this.camera.getWorldDirection(FWD); FWD.y = 0; FWD.normalize();
                    RIGHT.crossVectors(FWD, new THREE.Vector3(0, 1, 0)).normalize();

                    this.renderer.xr.getSession().inputSources.forEach(src => {
                        const gp = src.gamepad; if (!gp) return;
                        const sx = gp.axes[2] || 0, sy = gp.axes[3] || 0;

                        /* left-stick – move / run */
                        if (src.handedness === 'left') {
                            const tgtMul = gp.buttons[1]?.value > 0.5 ? MAX_RUN : MIN_RUN;
                            inp.runMul += (tgtMul - inp.runMul) * RUN_EASE * dt;

                            if (Math.hypot(sx, sy) > DEADZONE) {
                                this.dolly.position.addScaledVector(
                                    RIGHT, sx * BASE_SPEED * dt * inp.runMul
                                );
                                this.dolly.position.addScaledVector(
                                    FWD, -sy * BASE_SPEED * dt * inp.runMul
                                );
                            }
                        }

                        /* right-stick – yaw / jump / crouch */
                        if (src.handedness === 'right') {
                            if (Math.abs(sx) > DEADZONE)
                                this.dolly.rotation.y -= sx * YAW_SPEED * dt;

                            if (sy < -DEADZONE && inp.jumpState === 'idle')
                                inp.jumpState = 'up';          // start jump next frame

                            inp.crouch = sy > DEADZONE;
                        }
                    });
                }
                /* --------------------- desktop / mobile locomotion ------------------ */
                else {
                    /* phone-orientation “look” --------------------------------------- */
                    if (this.platform.isMobile && this.orientation.ready) {
                        const { alpha: a, beta: b, gamma: g } = this.orientation;
                        const euler = new THREE.Euler(
                            THREE.MathUtils.degToRad(b),
                            THREE.MathUtils.degToRad(a),
                            THREE.MathUtils.degToRad(-g),
                            'YXZ'
                        );
                        const quat = new THREE.Quaternion().setFromEuler(euler)
                            .multiply(
                                new THREE.Quaternion().setFromAxisAngle(
                                    new THREE.Vector3(1, 0, 0), -Math.PI / 2
                                )
                            );
                        this.dolly.quaternion.copy(quat);
                    }

                    /* keyboard / touch movement -------------------------------------- */
                    if (inp.controls.isLocked || this.platform.isMobile) {
                        this.camera.getWorldDirection(FWD); FWD.y = 0; FWD.normalize();
                        RIGHT.crossVectors(FWD, new THREE.Vector3(0, 1, 0)).normalize();

                        let mx = 0, mz = 0;
                        if (inp.forward) mz++;
                        if (inp.backward) mz--;
                        if (inp.left) mx--;
                        if (inp.right) mx++;

                        mx += this.slide.x * this.slide.mag;
                        mz -= this.slide.y * this.slide.mag;

                        if (mx || mz) {
                            const dir = new THREE.Vector3()
                                .addScaledVector(RIGHT, mx)
                                .addScaledVector(FWD, mz)
                                .normalize();
                            const speed = BASE_SPEED * (inp.shift ? MAX_RUN : MIN_RUN);
                            this.dolly.position.addScaledVector(dir, speed * dt);
                        }
                    }
                }

                /* 2nd clamp in case _snap() ran after our logic ---------------------- */
                this.dolly.position.y = inp.groundY + inp.eyeY;
            }



        }


        class App {
            constructor() {
                if (location.protocol !== 'https:') {
                    location.href = 'https:' + window.location.href.substring(location.protocol.length);
                }

                // ─── core setup ───────────────────────────────────
                this.platform = new Platform();
                this.hintEl = document.getElementById('hint');
                this.requestBtn = document.getElementById('request');
                this.sensorMgr = new SensorManager(this.requestBtn, this.hintEl, this.platform);
                new GeoRequester(document.getElementById('geo'));

                this.sceneMgr = new SceneManager(this.platform);
                new XRControllerManager(this.sceneMgr.renderer, this.sceneMgr.dolly);

                this.hexGridMgr = new TileManager(this.sceneMgr.scene, 5, 100, elevSocket);
                // ─── peer sync ─────────────────────────────────────────────────────────
                this.peerMgr = new PeerManager(
                    SIGNALING_SERVER,
                    this.sceneMgr.scene,
                    this.sceneMgr.dolly,
                    this.sceneMgr.camera,
                    this.hexGridMgr
                );
                // 1) first define your movement state (including baseEye)
                this.movement = {
                    forward: false, backward: false, left: false, right: false,
                    shift: false, crouch: false,
                    groundY: 0,
                    baseEye: 1.6, eyeY: 1.6,
                    crouchEye: 0.8, jumpPeak: 2.4, jumpState: 'idle',
                    runMul: 1,
                    slide: { x: 0, y: 0, mag: 0 },
                    controls: null    // will fill in next
                };

                // 2) now build pointer‐lock around the camera
                this.controls = new PointerLockControls(this.sceneMgr.camera, document.body);

                // 3) attach the control’s own pivot back onto the dolly,
                //    and lift it up by baseEye so rotation centers at head height
                this.sceneMgr.dolly.add(this.controls.getObject());

                // 4) finish wiring movement.controls and InputManager
                this.movement.controls = this.controls;
                this.inputMgr = new InputManager(
                    this.platform,
                    this.sceneMgr.renderer,
                    this.controls,
                    this.movement,
                    this.movement.slide,
                    this.sensorMgr
                );

                // 5) snap into place one first time
                this._snap();


                this.consts = {
                    BASE_SPEED: 2, YAW_SPEED: 1.5, DEADZONE: 0.2,
                    RUN_EASE: 3, MIN_RUN: 1, MAX_RUN: 3,
                    JUMP_EASE: 4, CROUCH_EASE: 6,
                    vectors: { FWD: new THREE.Vector3(), RIGHT: new THREE.Vector3() }
                };
                this.moveCtrl = new MovementController(
                    this.sceneMgr, this.movement, this.consts, this.platform
                );

                // ─── birds-eye spherical & speed setup ─────────────────
                this.birdsCamera = new THREE.PerspectiveCamera(
                    75, window.innerWidth / window.innerHeight, 0.05, 1000
                );
                this._birdsOffsetEnd = new THREE.Vector3(0, 200, -200);
                this._birdsSphericalStart = new THREE.Spherical();
                this._birdsSphericalEnd = new THREE.Spherical();
                this._birdsSphericalCur = new THREE.Spherical();
                this._birdsSphericalEnd.setFromVector3(this._birdsOffsetEnd);
                this._basePhi = this._birdsSphericalEnd.phi;
                const maxDeg = 20;
                this._maxPitchDelta = THREE.MathUtils.degToRad(maxDeg);
                this._minPhi = this._basePhi - this._maxPitchDelta;
                this._maxPhi = this._basePhi + this._maxPitchDelta;

                this._birdsLerp = 0;
                this.isBirdsEye = false;
                this._resetPitch = false;
                this._pitchEase = 5;
                this._pitchResetTimeout = null;

                // birds-eye speed multipliers
                this.shiftHoldTime = 0;
                this.birdWalkMultiplier = 20;
                this.birdRunRampRate = 0.5;
                this.maxBirdRunMultiplier = 4;

                // track whether pointer is locked for orbit
                this.birdsPointerLocked = false;

                // bind & listen
                this._onWheel = this._onWheel.bind(this);
                this._onBirdsMouse = this._onBirdsMouse.bind(this);
                this._onPointerLockChange = this._onPointerLockChange.bind(this);
                this._onClickLock = this._onClickLock.bind(this);

                window.addEventListener('wheel', this._onWheel, { passive: true });
                window.addEventListener('mousemove', this._onBirdsMouse);
                window.addEventListener('resize', () => this._onResize());
                document.addEventListener('pointerlockchange', this._onPointerLockChange);
                // allow re-locking when clicking in birds-eye
                window.addEventListener('click', this._onClickLock);

                this.clock = new THREE.Clock();
                this.sceneMgr.renderer.setAnimationLoop(() => this._update());
            }

            _snap() {
                const pos = this.sceneMgr.dolly.position;
                const h = this.hexGridMgr.getHeightAt(pos.x, pos.z);
                this.sceneMgr.dolly.position.y = h + this.movement.baseEye;
            }

            _onResize() {
                const w = window.innerWidth, h = window.innerHeight;

                // update cameras
                this.sceneMgr.camera.aspect = w / h;
                this.birdsCamera.aspect = w / h;
                this.sceneMgr.camera.updateProjectionMatrix();
                this.birdsCamera.updateProjectionMatrix();

                // update renderer *and* post-processing composer
                this.sceneMgr.renderer.setSize(w, h);
                this.sceneMgr.composer.setSize(w, h);
            }


            _onWheel(evt) {
                if (evt.deltaY > 0) {
                    if (!this.isBirdsEye) this._enterBirdsEye();
                } else {
                    if (this.isBirdsEye) this._exitBirdsEye();
                }
            }

            _enterBirdsEye() {
                // request pointer lock immediately
                this.sceneMgr.renderer.domElement.requestPointerLock();

                // capture start spherical
                const dollyPos = this.sceneMgr.dolly.position;
                this.sceneMgr.camera.getWorldPosition(this._tempV || (this._tempV = new THREE.Vector3()));
                this._tempV.sub(dollyPos);
                this._birdsSphericalStart.setFromVector3(this._tempV);

                // set target spherical to end-offset
                this._birdsSphericalEnd.setFromVector3(this._birdsOffsetEnd);

                this._birdsLerp = 0;
                this.isBirdsEye = true;
                this.shiftHoldTime = 0;
            }

            _exitBirdsEye() {
                this.isBirdsEye = false;
                clearTimeout(this._pitchResetTimeout);
                this._resetPitch = false;
                this.shiftHoldTime = 0;

                // exit pointer lock if we had it
                if (document.pointerLockElement === this.sceneMgr.renderer.domElement) {
                    document.exitPointerLock();
                }

                // immediately re-snap the dolly to the surface
                this._snap();
            }


            _onPointerLockChange() {
                // update lock state only when in birds-eye
                this.birdsPointerLocked = (
                    this.isBirdsEye &&
                    document.pointerLockElement === this.sceneMgr.renderer.domElement
                );
            }

            _onClickLock() {
                // on click, if zoomed-out but unlocked, re-request lock
                if (this.isBirdsEye && !this.birdsPointerLocked) {
                    this.sceneMgr.renderer.domElement.requestPointerLock();
                }
            }

            _onBirdsMouse(evt) {
                // only orbit if fully zoomed-out AND pointer locked
                if (!this.isBirdsEye || this._birdsLerp < 1 || !this.birdsPointerLocked) return;

                // yaw
                this._birdsSphericalEnd.theta += -evt.movementX * 0.002;
                // pitch
                this._birdsSphericalEnd.phi += -evt.movementY * 0.002;
                this._birdsSphericalEnd.phi = THREE.MathUtils.clamp(
                    this._birdsSphericalEnd.phi,
                    this._minPhi,
                    this._maxPhi
                );
                // schedule pitch reset
                clearTimeout(this._pitchResetTimeout);
                this._resetPitch = false;
                this._pitchResetTimeout = setTimeout(() => {
                    this._resetPitch = true;
                }, 200);
            }

            _update() {

                this.sceneMgr.hTilt.enabled = this.isBirdsEye;
                this.sceneMgr.vTilt.enabled = this.isBirdsEye;
                const dt = this.clock.getDelta();
                const pos = this.sceneMgr.dolly.position;

                // always keep dolly riding the terrain
                const h = this.hexGridMgr.getHeightAt(pos.x, pos.z);
                pos.y = h + this.movement.baseEye;
                this.movement.groundY = h;

                // first-person update
                if (!this.isBirdsEye) {
                    this._snap();
                    this.moveCtrl.update(dt);
                }

                // update tiles, peers, UI hash
                this.hexGridMgr.update(pos);
                const hashEl = document.getElementById('curHash');
                if (hashEl) hashEl.textContent = this.hexGridMgr.getCurrentHash(pos) || '--';
                this.peerMgr.broadcastPose();
                this.peerMgr.updatePeers(dt);

                if (this.isBirdsEye) {
                    // —── birds-eye interpolation & orbit (unchanged) ───—
                    if (this._birdsLerp < 1) {
                        this._birdsLerp = Math.min(1, this._birdsLerp + dt / 0.5);
                    }
                    if (this._birdsLerp >= 1 && this._resetPitch) {
                        const diff = this._basePhi - this._birdsSphericalEnd.phi;
                        this._birdsSphericalEnd.phi += diff * Math.min(1, this._pitchEase * dt);
                        if (Math.abs(diff) < 1e-3) {
                            this._birdsSphericalEnd.phi = this._basePhi;
                            this._resetPitch = false;
                        }
                    }
                    this._birdsSphericalCur.radius = THREE.MathUtils.lerp(
                        this._birdsSphericalStart.radius,
                        this._birdsSphericalEnd.radius,
                        this._birdsLerp
                    );
                    this._birdsSphericalCur.theta = THREE.MathUtils.lerp(
                        this._birdsSphericalStart.theta,
                        this._birdsSphericalEnd.theta,
                        this._birdsLerp
                    );
                    this._birdsSphericalCur.phi = THREE.MathUtils.lerp(
                        this._birdsSphericalStart.phi,
                        this._birdsSphericalEnd.phi,
                        this._birdsLerp
                    );

                    // compute offset from spherical, but force vertical = N
                    const offset = this._offsetV || (this._offsetV = new THREE.Vector3());
                    offset.setFromSpherical(this._birdsSphericalCur);
                    const N = 200;  // desired height above ground
                    offset.y = N;

                    // position birdsCamera relative to terrain at dolly
                    this.birdsCamera.position.set(
                        pos.x + offset.x,
                        h + offset.y,
                        pos.z + offset.z
                    );
                    this.birdsCamera.lookAt(pos.x, h, pos.z);

                    // allow movement in birds-eye mode
                    if (this.movement.shift) this.shiftHoldTime += dt;
                    else this.shiftHoldTime = 0;
                    const walkM = this.birdWalkMultiplier;
                    const runM = Math.min(this.maxBirdRunMultiplier,
                        1 + this.shiftHoldTime * this.birdRunRampRate);
                    const mult = this.movement.shift ? runM : walkM;
                    const speed = this.consts.BASE_SPEED * dt * mult;
                    const fwd = this.birdsCamera.getWorldDirection(new THREE.Vector3())
                        .setY(0).normalize();
                    const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0, 1, 0));
                    if (this.movement.forward) pos.addScaledVector(fwd, speed);
                    if (this.movement.backward) pos.addScaledVector(fwd, -speed);
                    if (this.movement.left) pos.addScaledVector(right, -speed);
                    if (this.movement.right) pos.addScaledVector(right, speed);

                    // **direct** render with birdsCamera (bypass composer)
                    this.sceneMgr.renderer.render(
                        this.sceneMgr.scene,
                        this.birdsCamera
                    );

                } else {
                    // first-person: go through the composer
                    this.sceneMgr.render();
                }
            }
        }

        window.addEventListener('DOMContentLoaded', () => new App());


    </script>
    <!-- Note: include LZString library for compression/decompression -->
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
</body>

</html>
